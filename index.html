<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Duck Dash: Event Edition</title>
    <style>
        :root { --neon-yellow: #f1c40f; --bg-dark: #0f172a; }
        body { 
            margin: 0; padding: 0; background: var(--bg-dark); 
            color: white; font-family: 'Inter', system-ui, sans-serif;
            overflow-x: hidden; touch-action: manipulation;
        }
        .container { display: flex; flex-direction: column; height: 100vh; }
        
        /* Smooth UI Header */
        header { 
            padding: 15px; background: rgba(30, 41, 59, 0.8); 
            backdrop-filter: blur(10px); border-bottom: 2px solid #334155;
        }
        .input-group { display: flex; gap: 8px; flex-direction: column; max-width: 500px; margin: 0 auto; }
        textarea { 
            background: #1e293b; border: 1px solid #475569; color: white;
            padding: 12px; border-radius: 8px; resize: none; font-size: 14px;
        }
        .controls-row { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
        
        button { 
            background: var(--neon-yellow); color: black; border: none;
            padding: 12px 24px; border-radius: 8px; font-weight: 800;
            text-transform: uppercase; cursor: pointer; transition: 0.2s;
        }
        button:active { transform: scale(0.95); }

        #status-bar { 
            text-align: center; font-weight: 900; font-size: 1.2rem;
            padding: 10px; color: var(--neon-yellow); height: 30px;
        }

        /* Canvas should fill remaining space */
        #game-wrapper { flex-grow: 1; position: relative; width: 100%; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <div class="input-group">
            <textarea id="nameInput" placeholder="Enter names separated by commas...">Alex, Jordan, Taylor, Sam, Quinn, Casey</textarea>
            <div class="controls-row">
                <div style="font-size: 12px;">
                    TIME: <span id="timeDisplay">20</span>s<br>
                    <input type="range" id="durationInput" min="5" max="60" value="20" 
                           oninput="document.getElementById('timeDisplay').innerText=this.value">
                </div>
                <button onclick="startRace()">Launch Race</button>
            </div>
        </div>
    </header>

    <div id="status-bar">READY FOR THE DROP</div>

    <div id="game-wrapper">
        <canvas id="raceCanvas"></canvas>
    </div>
</div>

<script>
    const canvas = document.getElementById('raceCanvas');
    const ctx = canvas.getContext('2d');
    const statusBar = document.getElementById('status-bar');
    let ducks = [];
    let racing = false;
    let startTime, duration;
    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playBeep(freq = 440, duration = 0.1) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = canvas.parentElement.clientHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function startRace() {
        const names = document.getElementById('nameInput').value.split(/[, \n]+/).filter(n => n.trim() !== "");
        if(names.length < 1) return;
        
        duration = document.getElementById('durationInput').value * 1000;
        const laneHeight = canvas.height / (names.length + 1);

        ducks = names.map((name, i) => ({
            name: name,
            x: 40,
            y: laneHeight * (i + 1),
            color: `hsl(${Math.random() * 360}, 80%, 60%)`, // Unique name color
            progress: 0,
            offset: Math.random() * 100,
            finished: false
        }));

        startTime = Date.now();
        racing = true;
        statusBar.innerText = "ðŸš¥ BEEP... BEEP... GO!";
        playBeep(880, 0.2);
        animate();
    }

    function drawDuck(x, y, nameColor, name) {
        ctx.save();
        ctx.translate(x, y);
        
        // Body (Yellow)
        ctx.fillStyle = "#f1c40f";
        ctx.beginPath();
        ctx.ellipse(0, 0, 18, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head (Yellow)
        ctx.beginPath();
        ctx.arc(12, -10, 10, 0, Math.PI * 2);
        ctx.fill();

        // Eye
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(15, -12, 1.5, 0, Math.PI * 2);
        ctx.fill();

        // Beak
        ctx.fillStyle = "#e67e22";
        ctx.beginPath();
        ctx.moveTo(20, -10); ctx.lineTo(28, -8); ctx.lineTo(20, -6);
        ctx.fill();

        // Name Tag (The distinct part)
        ctx.fillStyle = nameColor;
        ctx.font = "bold 14px sans-serif";
        ctx.textAlign = "center";
        ctx.shadowBlur = 4;
        ctx.shadowColor = "black";
        ctx.fillText(name, 0, -28);
        
        ctx.restore();
    }

    function animate() {
        if (!racing) return;
        const now = Date.now();
        const elapsed = now - startTime;
        const rawProgress = Math.min(elapsed / duration, 1);
        
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Finish Line
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(canvas.width - 60, 0);
        ctx.lineTo(canvas.width - 60, canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);

        ducks.forEach(duck => {
            if (!duck.finished) {
                // Suspense logic: Add micro-variations to progress
                let noise = Math.sin(elapsed / 400 + duck.offset) * 0.02;
                duck.progress = rawProgress + noise;
                
                // Random Boosts
                if(Math.random() > 0.997) {
                    playBeep(660, 0.05);
                    duck.progress += 0.05;
                }

                duck.x = 40 + (canvas.width - 120) * Math.max(0, duck.progress);

                if (duck.x >= canvas.width - 80) {
                    duck.finished = true;
                    if(ducks.filter(d => d.finished).length === 1) {
                        statusBar.innerText = `ðŸ† WINNER: ${duck.name.toUpperCase()}`;
                        playBeep(1100, 0.3);
                    }
                }
            }
            drawDuck(duck.x, duck.y, duck.color, duck.name);
        });

        if (ducks.every(d => d.finished)) {
            racing = false;
        } else {
            requestAnimationFrame(animate);
        }
    }
</script>
</body>
</html>
